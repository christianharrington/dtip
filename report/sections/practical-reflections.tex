%!TEX root = ../main.tex
\section{Practical Reflections}
\label{sec:practical-reflections}
In this section we will reflect on some of the lessons we have learned when working with dependent types. We will also relate some of the practical problems we have encountered, both with Idris and dependent types in general.

\subsection{Decidable Equality}
While implementing the type checking algorithm from Section~\ref{sec:type-checking}, a notion of equality between \texttt{Tip}s was needed. A simple solution would be to implement this as a Boolean function. However, Booleans encode very little information, and we would like to have a richer notion of equality to be able to provide static guarantees of equality within the type system. This can be achieved using decidable equality, where one is required to give a proof specifying why two terms are equal (if they are in fact equal) or why not. Using dependent types, we found that it is rarely useful to use Boolean values, as they do not provide any guarantees upon which other definitions can be built.

\subsection{Invariants in Types}
With dependently typed programming, the richer type system helps when specifying stronger claims. As programmers who are unexperienced with dependent types, this is both a blessing and a curse. Sometimes the falsehood of an invariant does not become apparent until one realizes that the implementation is impossible. For example, our definition of a program for our stack machine in Figure~\ref{fig:idris_impl_of_prg} has been through many iterations. As one becomes more and more experienced in dependently typed programming, the process of determining a correct invariant becomes easier.

Once getting used to defining types for dependent functions, you can really feel the power of dependent types. When we, for example, defined append for programs in Section~\ref{sec:program}, we took advantage of the fact that implicit arguments in dependent functions are universally quantified. This allowed us to concatenate programs as long as the type checker was able to unify their indices.

\subsection{Implementation with Proofs}
Due to the Curry-Howard correspondence, it is possible to implement any function as a proof. In Idris, this can be done using the Idris theorem prover. We found this tool to be quite useful in several situations, especially when defining a decision procedure for equality on \texttt{Tip}. Also, if one were to provide a proof of evaluation for well-typed terms using the \texttt{Step} relation defined in Section~\ref{sec:partiality}, the theorem prover would prove to be very helpful. As such, knowing when the theorem prover might help you solve your problem more easily turned out to be beneficial.

\subsection{Issues Concerning the Idris Coverage Checker}
In the process of implementing the stack machine defined in Section~\ref{sec:stack-machine}, we encountered an issue with the Idris coverage checker. Because the coverage checker was checking all the implicit arguments to a function, coverage checking of our \texttt{compile} function was slowed down considerably when adding the cases for binary operators. Edwin Brady resolved this issue by making the coverage checker remember which implicit arguments were generated automatically, and which were supplied by the programmer\footnote{\emph{Idris-dev} at github.com. Issue \#535: Massive slowdown in coverage checker. \url{https://github.com/idris-lang/Idris-dev/issues/535}}. In this sense, our project contributed to the improvement of the language.
 
\subsection{Getting Definitions Right --- Vect Properties}
The substitution function described in Section~\ref{sec:partiality} posed some challenges concerning the definitions of some of the auxiliary functions. Specifically, the \texttt{weaken}, \texttt{append}, and \texttt{prepend} functions are all defined in terms of vectors, and our initial definitions (and attempted implementations) of these relied on the ability to rewrite with dependent equalities, i.e. equalities between terms of dependent types (such as \texttt{Vect}). At first, we assumed that this would be just as easy as rewriting with non-dependent equalities, but after a considerable amount of effort, it seemed that our approach was wrong. Consequently, we posted a question concerning this issue to the Idris mailing list\footnote{Idris Programming Language mailing list. Proving properties about Vect: \url{https://groups.google.com/forum/#!topic/idris-lang/iNNYoE0k27A}}. Although quite a few clever solutions were proposed, rewriting with dependent equalities had not been implemented in Idris beforehand, as no one else had ever needed it. After trying to use some of these solutions, we at last arrived at a solution which did not required rewriting with dependent equalities at all.
