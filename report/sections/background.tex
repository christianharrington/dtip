%!TEX root = ../main.tex
\section{Background}
\label{sec:background}

\subsection{Simply Typed Lambda Calculus}
\label{sec:stlc}
The simply typed lambda calculus is a formal system based on the untyped lambda calculus, extending it, as the name implies, with a simple type system. The language itself consists of three terms: \emph{variable}, \emph{abstraction} and \emph{application}, with three simple typing rules (see Figure~\ref{fig:simple-typing-rules}), along with three simple evaluation rules (see Figure~\ref{fig:simple-evaluation-rules})\,\cite[pp. 99]{Pierce:TypeSystems}.

\begin{center}
\begin{figure}

\begin{prooftree}
\AxiomC{x : T $\in \Gamma$}
\RightLabel{\sc{(T-Var)}}
\UnaryInfC{$\Gamma \vdash$ x : T}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma$, x : T$_{1} \vdash$ t$_{2}$ : T$_{2}$}
\RightLabel{\sc{(T-Abs)}}
\UnaryInfC{$\Gamma \vdash \lambda$x : T$_{1}$ . t$_{2}$ : T$_{1} \to$ T$_{2}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash$ t$_{1}$ : T$_{11} \to $ T$_{_12}$}
\AxiomC{$\Gamma \vdash$ t : T$_{11}$}
\RightLabel{\sc{(T-App)}}
\BinaryInfC{$\Gamma \vdash$ t$_{1}$ t$_{2}$ : T$_{12}$}
\end{prooftree}

\caption{Typing rules for the simply typed lambda calculus.}
\label{fig:simple-typing-rules}

\end{figure}
\end{center}

\begin{center}
\begin{figure}

\begin{prooftree}
\AxiomC{t$_{1} \to$ t$_{1}^{\prime}$}
\RightLabel{\sc{(E-App1)}}
\UnaryInfC{t$_{1}$ t$_{2}$ $\to$ t$_{1}^{\prime}$ t$_{2}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{t$_{2} \to$ t$_{2}^{\prime}$}
\RightLabel{\sc{(E-App2)}}
\UnaryInfC{v$_{1}$ t$_{2}$ $\to$ v$_{1}$ t$_{2}^{\prime}$}
\end{prooftree}

\begin{center}
($\lambda$x : T$_{11}$.t$_{12}$) v$_{2} \to$ [x $\mapsto$ v$_{2}$]t$_{12}$ \sc{(E-AppAbs)}
\end{center}

\caption{Evaluation rules for the simply typed lambda calculus.}
\label{fig:simple-evaluation-rules}

\end{figure}
\end{center}

The simply typed lambda calculus has the property of \emph{strong normalization}\,\cite[pp. 149]{Pierce:TypeSystems}: After finite number of reductions, we will arrive at a normal form. This means that when evaluating a term, the evaluation will always terminate. As a consequence of this, the simply typed lambda calculus is not Turing-complete.

This system will be the foundation of the language presented in the next sections. You will also see several extensions to the calculus, such as the addition of sum and product types.

\subsection{Dependent Types}
\label{sec:dependent-types-idris}
% - "Correct by construction"
% - Extrinsic vs intrinsic verification
In many modern programming languages, types can be parameterized by other types. This is often seen in generic collection types such as \texttt{List: Type $\to$ Type}, which is parameterized by the type contained in the list. But in programming languages with dependent types, types can also depend on terms. The classic example is the dependent vector, \texttt{Vect: Nat $\to$ Type $\to$ Type}, where the natural number is the length of the vector. When a type depends on a term, one says the type is \emph{indexed} by that term, as opposed to being \emph{parameterized} by a type. So \texttt{Vect n A} is a type \emph{indexed} over the natural number \texttt{n}, and \emph{parameterized} by the type \texttt{A}. The constructors for the vector data type can be seen in Figure~\ref{fig:vect}.

\begin{figure}
\begin{alltt}
data Vect : Nat -> Type -> Type where
  Nil  : Vect Z a
  (::) : a -> Vect k a -> Vect (S k) a
\end{alltt}
\caption{The vector data type. \texttt{Z} and \texttt{(S k)} are constructors for Nat, where \texttt{Z} represents 0, and \texttt{(S k)} represents the natural number succeeding \texttt{k}. So \texttt{(S (S Z))} represents 2.}
\label{fig:vect}
\end{figure}

To see how dependent types can be useful, let us look at the \texttt{zip} function for lists and vectors. The \texttt{zip} function for lists has the type \textit{List A $\to$ List B $\to$ List (A, B)}. The \texttt{zip} function takes two lists of elements, and returns a list of pairs of elements from each list. But what happens if one list is longer than the other? Does the \texttt{zip} function simply stop zipping when it reaches the end of one of the lists? Or does it fill the remaining pairs with some default value? We have no way of knowing without reading the documentation or looking through the source.

When types can depend on values, it becomes possible to build strong invariants into the types themselves, which lets the type checker figure out whether they hold. In Figure~\ref{fig:zip}, a zip function for the dependent vector is defined. It takes two vectors with the length \texttt{n}, and returns a vector with length \texttt{n}. If someone tries to compile a program that tries to zip vectors of different lengths, and therefore different types, the type checker will catch it, and the program will not compile. Notice that we do not need to match on the cases where one vector is empty while the other still has elements, as the vectors are of equal length in every iteration. In fact, the type checker will not even let us check for this case, as it is not well-typed.

\paragraph{Correct by construction} Dependent types help us to write programs and functions that are \emph{correct by construction}\,\cite[p. 464]{Pierce:TypeSystems}. When a function is correct by construction, it means the type encodes all the invariants we want to hold, and if the type checker agrees that our functions have this type, we have proof that our program lives up to our specification. This is directly related to the Curry-Howard correspondence\,\cite{Pierce:TypeSystems}, which relates logic and type theory. Specifically, logical propositions corresponds to types, and a proof of proposition $P$ corresponds to a term with type $P$.

\paragraph{Intrinsic and extrinsic proofs} In the \texttt{zip} function, we have an \emph{intrinsic} proof that the resulting vector is the same length as the two input vectors. It is intrinsic as it is contained in the definition itself. Without dependent types, we would have to have an \emph{extrinsic} proof, a separate proof stating the lengths are the same. Even with dependent types, it can sometimes be easier to weaken the definition, and instead rely on an external proof for correctness. As a final example, we will define the finite set data type \texttt{Fin}, which can be seen in Figure~\ref{fig:fin}\todo{This might be going in another section}.

Dependent types have been implemented in several programming languages, such as Coq\,\cite{Coq}, Agda\,\cite{Agda} and, of course, Idris. 

\begin{figure}
\begin{alltt}
zip : Vect n a -> Vect n b -> Vect n (a, b)
zip Nil       Nil       = Nil
zip (x :: xs) (y :: ys) = (x, y) :: zip xs ys
\end{alltt}
\caption{Zip function for vectors in Idris.}
\label{fig:zip}
\end{figure}

\begin{figure}
\begin{alltt}
data Fin : Nat -> Type where
  fZ : Fin (S k)
  fS : Fin k -> Fin (S k)
\end{alltt}
\caption{\texttt{Fin} represents a finite set with \texttt{(S k)} elements. It can be used to represent bounded natural numbers.}
\label{fig:fin}
\end{figure}
