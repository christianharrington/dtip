%!TEX root = ../main.tex
\section{Stack Machine}
\label{sec:stack-machine}
Now that we have a well-typed expression language, we would like to be able to compile and execute it. This means we need a compiler to translate the expression language to instructions, and a stack machine to run these instructions.

\subsection{Standard Stack Machine}
A minimal stack machine needs only a few components: a list of instructions, a program counter (PC), a stack, and a stack pointer (SP). The program counter records how far into the array of instructions we are, and the stack pointer points to the topmost element of the stack. As each instruction is evaluated, the stack is manipulated and the program counter is increased. The instructions are usually encoded using postfix notation. For example, if you want to add the constants 3 and 4 together, the instructions required would be: [PUSH 3, PUSH 4, ADD]. The first two instructions push the constants onto the stack, and the third instruction adds them together, and leaves the result on the stack.

\subsubsection{Problems}
In most implementations, the stack machine is not in it self very safe. It is up to the compiler to make sure all the instructions are correct. But there is nothing in the program representation or the stack machine stopping the compiler from producing impossible programs. For example, the program [PUSH 3, ADD] will result in a stack underflow error, as the ADD instruction is expecting 2 values on the stack.

\subsection{Desired Qualities}
Since our expression language is safe, we would like our compiled programs to retain as much of that safety as possible. In this case, we will ensure the compiler can never produce a program with stack underflow errors.

% What would we like in our stack machine. Our language is safe -> our bytecode should be safe. We can do this with DT
% Christian
\input{sections/program_representation}
\input{sections/compile}
\subsection{Run}
% What does all this mean when we run our program
