%!TEX root = ../main.tex
\section{Stack Machine}
\label{sec:stack-machine}

% - Hvad er en stack machine?
% - Udfordringer
% - LÃ¸sninger
% - Program representation
% - Compilation
% - Execution

Now that we have a well-typed expression language, we would like to be able to compile and execute it. This means we need a compiler to translate the expression language to instructions, and a machine to run these instructions. Due to its simplicity, we have chosen the stack machine.
\\
A minimal stack machine needs only a few components: a list of instructions, a program counter (PC), a stack, a stack pointer (SP) and a heap. The program counter records how far into the array of instructions we are, and the stack pointer points to the topmost element of the stack. The heap is used to store data. As each instruction is executed, the stack is manipulated and the program counter is increased. Because each instruction operates on the top of the stack, programs are written in a postfix style. For example, if you want to add the constants 3 and 4 together, the instructions required would be: [PUSH 3, PUSH 4, ADD]. The first two instructions push the constants onto the stack, and the third instruction adds them together, and leaves the result on the stack. Thus the stack effect of the PUSH instructions is to add one value to the stack each, and the effect of the ADD instruction is to consume two values from the stack, and leave one value. The stack effect of the two instruction can be written (0, 1) and (2, 1), respectively.

\subsubsection{Problems}
In most stack machine implementations, many errors can occur at run time. For example, running the program [PUSH 3, ADD] with an empty stack will result in a stack underflow error, as the ADD instruction is expecting 2 values on the stack\todo{More errors?}. It is up to the compiler to make sure all the instructions are correct. Unfortunately, most compilers are not accompanied by a proof of correctness. Instead they are thoroughly tested. As a consequence, even if you have proved the correctness of your program, as soon as you compile it with an unverified compiler, you lose all assurances. \cite{Leroy_formalverification}

\subsection{Desired Qualities}
While it is beyond the scope of this project to produce a fully verified compiler and stack machine, we can use dependent types to make certain guarantees about the compiler, the programs it produces, and the stack machine that runs the programs. Specifically, we would like a program representation that encodes the stack effect of the instructions that comprise it, and a stack machine that only accepts such a \textit{well-stacked} program that will run with an empty stack, without any stack underflow errors. The stack machine will be very simple. Instead of using a program counter and a stack pointer, the program and the stack themselves will be passed as parameters to the stack machine. As the stack machine is only used to run programs compiled from the well-typed expression language, a heap is not needed, and will not be implemented.

\input{sections/program_representation}
\input{sections/compile}
\subsection{Run}
\label{sec:running_a_program}
% What does all this mean when we run our program
