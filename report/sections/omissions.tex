%!TEX root = ../main.tex
\subsection{Omissions}
\label{sec:omissions}\todo{Update omissions to most recent work before hand-in}
As previously mentioned our compile function, and thereby our stack machine, does not cover our entire well-typed expression language. Specifically the sum type, product type, and fixed point representations are not handled. 

\paragraph{Sum and Product Types}
These could be handled in two different ways. Either run both branches, choose one, and throw the result of the other one away, or make the decision before running a branch. This is a matter of whether the operator that chooses a branch (i.e. Fst or Snd) is before or after the branches in the program. Both ways have complications when working with our well-stacked stack machine. 

The first will cause issues in terms of the stack effect of an instruction. Since the result of one branch will need to be thrown away, the instruction choosing a branch will have the effect of consuming one branch (the one thrown away). This is inconsistent with our invariant when compiling which dictates that, compiling any expression will result in an instruction with an effect corresponding to the type of the compiled expression. 

The former causes violations with the invariant when running, which states that running a program with stack effect $(s, s')$ on a stack of size $s$ must result in a stack of size $s'$. When throwing away the unwanted branch of the program, the resulting program might be inconsistent with the invariant since we have no way of knowing the stack effect of a program without a certain amount of instructions. % There may be a way to work around for both of these by altering the invariants, but such solutions are likely to result in obscure code\todo{Consider explaining why, or reformulate}. 

\paragraph{Fixed points}
Compiling a fixed point for a stack machine that is not well-stacked is fairly straight forward. If treated like a function call, simply have a \texttt{CALL} instruction pointing to the start of the function with a conditional. With our well-stacked machine this is not as simple. Since our instructions are indexed by their stack effect, what stack effect would such a \texttt{CALL} instruction have? 

\paragraph{Possible Solution}
Both of the above issues could be solved by having an instruction where the effect is based on some parameter. We can use our previously defined \texttt{Eff} type for this. Consider the two functions, \texttt{stackReq} and \texttt{stackProduce}, in Figure~\ref{fig:stack_effect_functions}. These function produce a natural number based on an \texttt{Eff} and a natural number. These can be used to construct a variable instruction based on an \texttt{Eff} also seen in Figure~\ref{fig:stack_effect_functions}. The second parameter (\texttt{Nat}) in \texttt{CALL} indicates how to locate the function being called.

\begin{figure}
\begin{alltt}
stackProduce : Eff -> Nat -> Nat
stackProduce Flat n = n
stackProduce (Inc Z) n = S n
stackProduce (Inc m) n = S (m+n)
stackProduce (Dec _) n = n

stackReq : Eff -> Nat -> Nat
stackReq Flat n = n
stackReq (Dec Z) n = S n
stackReq (Dec m) n = S (m+n)
stackReq (Inc x) n = n

CALL : (e : Eff) -> Nat -> Inst (stackReq e s) (stackProduce e s)
\end{alltt}
\caption{Functions creating natural numbers from \texttt{Eff}s used for indexing instructions and the signature for a \texttt{CALL} instruction with variable indices based on an \texttt{Eff}.}
\label{fig:stack_effect_functions}
\end{figure}

This \texttt{CALL} instruction can be used to implement function calls, and thereby fixed points from our expression language. To do this we must also have a way of mapping the aforementioned \texttt{Nat} parameter to an actual function. To do this we need an additional layer of abstraction of programs. We introduce a program vector which is a vector of \texttt{Prog s s'}s, where each element in the vector can be thought of as a function. \texttt{CALL} $n$ would then execute the program that is $n$ further down the vector as illustrated in Figure~\ref{fig:program_structure}.

\begin{figure}
\begin{alltt}
p 0: [PUSH 2, CALL e 1, ADD]
     ::
p 1: [PUSH 1, CALL e 2, ADD]
     ::
p 2: Nil
     ::
p 3: [PUSH 4]
     ::
p 4: Nil
\end{alltt}
\caption{Possible program structure with functions. p 0--5 are the programs in the program vector.}
\label{fig:program_structure}
\end{figure}

In this example, \texttt{p 0} is the main program. \texttt{CALL e 1} indicates a call to the next program in the program vector, \texttt{p 1}. \texttt{p 1} contains the instruction \texttt{CALL e 2}, which indicates another call this time to the program two further down the program vector. Note that this is a call to \texttt{p 3} as \texttt{CALL}s parameter is relative to the current program, and not a global index in the program vector. 

Compiling a fixed point expression from Figure~\ref{fig:idris-def-expr-lang} (\texttt{Fix e}) then would mean constructing a \texttt{CALL} instruction based on type of the expression and compiling the function \texttt{e} and adding it to the program vector. Since the stack effect of a type and a program resulting in the same type are identical, the effect of the \texttt{CALL} instruction and the compiled program will also be identical. When running the program this will allow this correspondence between effects will allow us to run the function in the place of a call as their stack effects match.

To ensure that \texttt{CALL} will not refer to a program not existing in the program instructions must also be indexed by the context they exist in. This way it can be enforced that the \texttt{Nat} in the \texttt{CALL} constructor will not be higher than the size of the program vector, possibly using a finite set instead of a \texttt{Nat}.

Note that since we can only call programs further down the program vector, mutual recursion is not possible. Regular recursion is available through \texttt{CALL~e~0}.

Interestingly enough the above way of handling function calls also works for pairs and sum types, by for example treating each part of a pair as a function, and \texttt{Fst} and \texttt{Snd} as function calls.

It is clear that implementing this would involve revamping most parts of the system to handle a program vector rather than just a program. Therefore, this has not been done due to time constraints. It is an excellent opportunity for future projects.